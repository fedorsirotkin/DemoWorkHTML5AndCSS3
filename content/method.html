<!DOCTYPE html>
<html lang="ru-RU">
    <head>
        <meta charset="UTF-8">
        <!-- <link rel="stylesheet" href="../css/style.css" type="text/css"/> -->
        <link rel="stylesheet" href="../css/style.css">
        <!-- <script src="js/script.js" type="text/javascript"></script> -->
        <script src="../js/jquery-3.2.1.min.js"></script>
        <script src="../js/script.js"></script>
        <title>Обзор методологий веб-разработки | Методологии и инструменты веб-разработки</title>
    </head>
    <body class="bg-dark">
        <a href="#" class="btntop">^</a>
        <div id="content" class="wrap">
            <header>
                <div><a href="../content.html">Перейти к содержанию</a></div>
                <h1 class="mainHeader">Обзор методологий веб-разработки</h1>
            </header>
            <section>
                <h2 id="part1"><span class="subtitle">БЭМ</span></h2>
            </section>
            <article contenteditable>
                <figure class="image">
                    <img src="../images/bem.png" width="480" height="287" alt="">
                    <figcaption><i>Рисунок 1 - <b>Яндекс.БЭМ</b></i></figcaption>
                </figure>
                <p>
                    Пожалуй, самая популярная сейчас методология в мире. Название означает «<b>Блок</b>, <b>элемент</b>, <b>модификатор</b>».
                </p>
                <p>
                    Эти категории играют следующие роли в коде:
                </p>
                <ul>
                    <li><b>блоки</b> могут использоваться в нескольких местах сайта;  </li>
                    <li><b>элементы</b> являются частью блока и не имеют функционального смысла вне блока;  </li>
                    <li><b>модификаторы</b> представляют собой свойства блока или элемента, которые меняют его внешний вид или поведение.</li>
                </ul>
                <p>
                    Из этих категорий строятся классы для непосредственного использования в CSS. При этом не следует использовать селекторы тэгов (это потенциально может помешать использовать блок/элемент в каком-то нестандартном месте на сайте, т.е. привязывает сущность к контексту); рекомендуется также избегать каскадных селекторов, т.к. получившийся класс сам по себе достаточно точно (специфично) выбирает соответствующий элемент.
                </p>
                <p>
                    Такой подход позволяет избавиться от непредсказуемых последствий каскада и изолирует отдельные модули друг от друга.
                </p>
                <p> 
                    Пример кода в стиле БЭМ:
                </p>
                <pre>
                    .block_element {...}
                    .block_element-modifier {...}
                </pre>
                <p> 
                    Для удобства используются разные разделители между блоком и элементом и между блоком/элементом и модификатором; при этом можно использовать любые разделители, однако они должны быть одинаковыми в рамках одного проекта.
                </p>
                <p>
                    А теперь о бочках меда и ложках дегтя:
                </p>
                <p> 
                    <b>Хорошо:</b> изолированность модулей друг от друга и отсутствие непредсказуемых каскадов селекторов.
                </p>
                <p> 
                    <b>Плохо:</b> не всегда длинные названия классов удобны для использования (для крупных проектов есть смысл использовать инструменты, автоматизирующие работу с БЭМ-разметкой).
                </p>
                <p>
                    Кстати, для написания кода в таком стиле раньше часто рекомендовали препроцессор Stylus, так как он позволяет писать код так:
                </p>
                <pre>
                    .block {
                        &-element {...}
                    }
                </pre>
                <p>
                    Сейчас так можно писать, используя как SASS, так и LESS.
                </p>
                <p> 
                    И еще одно замечание - в оригинальной методологии БЭМ используются названия модификаторов, содержащие саму модифицируемую величину, например, button--sizeLarge. Сейчас в небольших проектах многие разработчики не указывают ее для лаконичности: button--large.
                </p>
                <figure class="image">
                    <img src="../images/bemtwo.png" width="500" height="200" alt="">
                    <figcaption><i>Рисунок 2 - <b>Яндекс.БЭМ. Пример блока</b></i></figcaption>
                </figure>
            </article>
            <section>
                <h2 id="part2"><span class="subtitle">OOCSS</span></h2>
            </section>
            <article contenteditable>
                <figure class="image">
                    <img src="../images/oocss.png" width="500" height="200" alt="">
                    <figcaption><i>Рисунок 3 - <b>OOCSS</b></i></figcaption>
                </figure>
                <p> 
                    OOCSS означает объектно-ориентированный CSS (Object-Oriented CSS). В этот подход заложены две основные идеи:
                </p>
                <ul>
                    <li>Разделение структуры и оформления</li>
                    <li>Разделение контейнера и контента (содержимого)</li>
                </ul> 
                <p> 
                    Итак, «разделяй и властвуй». С помощью такой структуры разработчик получает общие классы, которые можно использовать в разных местах.
                </p>
                <p> 
                    А теперь - две новости (как водится, хорошая и плохая):
                </p>
                <ul>
                    <li><b>Хорошая</b>: уменьшение количества кода за счет повторного его использования (принцип DRY).</li>
                    <li><b>Плохая</b>: достаточно сложная поддержка: при изменении стиля конкретного элемента скорее всего придется менять не только CSS (т.к. большинство классов общие), но и добавлять классы в разметку.</li>
                </ul>
                <p> 
                    Кроме того, сам подход OOCSS предлагает не конкретные правила, а абстрактные рекомендации, поэтому метод достаточно сложен для применения на практике. 
                </p>
                <p>
                    Зато, как это иногда случается, некоторые идеи OOCSS вдохновили авторов на создание своих, более конкретных, способов структурирования кода - своеобразных форков OOCSS.
                </p>
            </article>
            <section>
                <h2 id="part3"><span class="subtitle">SMACSS</span></h2>
            </section>
            <article contenteditable>
                <p> 
                    SMACSS расшифровывается как «масштабируемая и модульная архитектура для CSS» (Scalable and Modular Architecture for CSS). 
                </p>
                <p> 
                    Основная цель подхода - уменьшение количества кода и на упрощение поддержки кода. 
                </p>
                <p> 
                    Итак, Джонатан предложил разделить стили на 5 частей (в порядке включения их в документ):
                </p>
                <ul>
                    <li><b>Base rules</b> - базовые стили. Это стили основных элементов сайта - body, input, button, ul, ol и т.п. В этой секции используются в основном селекторы тэгов и атрибутов, классы - в исключительных случаях (например, если у вас стилизованные JavaScript’ом селекты);</li>
                    <li><b>Layout rules</b> - стили макета. Здесь находятся стили глобальных элементов размеры шапки, футера, сайдбара и т.п. Джонатан предлагает использовать здесь id в селекторах, так как эти элементы не будут встречаться более 1 раза на странице. Однако автор статьи считает это плохой практикой (каждый раз, когда в стилях появляется id селектор, где-то в мире грустит котенок). Используйте классы и будет вам счастье.</li>
                    <li><b>Modules rules</b> - стили модулей, то есть блоков, которые могут использоваться несколько раз на одной странице. Для классов модулей не рекомендуется использовать id и селекторы тэгов (для многократного использования и независимости от контекста соответственно).</li>
                    <li><b>State rules</b> - стили состояния. В этом разделе прописываются различные состояния модулей и скелета сайта. Это единственный раздел, в котором допустимо использование ключевого слова «!important».</li>
                    <li><b>Theme rules</b> - оформление. Здесь описываются стили оформлений, которые со временем, возможно, нужно будет заменить (так удобно делать, например, новогоднее оформление; для html-тем, выставленных на продажу такие стили позволяют переключать цветовую гамму и т.п.).</li>
                </ul> 
                <p> 
                    Также рекомендуется вводить неймспейсы для классов, принадлежащих к определенной группе, а также использовать отдельный неймспейс для классов, используемых в JavaScript.
                </p>
                <p> 
                    Этот подход действительно позволяет упростить написание и поддержку кода и в последнее время привлекает достаточно большое количество разработчиков.
                </p>
                <figure class="image">
                    <img src="../images/smacss.png" width="500" height="200" alt="">
                    <figcaption><i>Рисунок 4 - <b>SMACSS</b></i></figcaption>
                </figure>
            </article>
            <section>
                <h2 id="part4"><span class="subtitle">Atomic CSS</span></h2>
            </section>
            <article contenteditable>
                <p>
                    Atomic CSS, редко также ACSS - атомарный CSS. В некотором роде этот подход представляет собой OOCSS, возведенный в абсолют. 
                </p>
                <p> 
                    При использовании такого подхода для каждого повторно используемого свойства должен быть сформирован отдельный класс. Пример: стиль «margin-top: 1px» предполагает создание класса «mt-1», стиль «width: 200px» создание класса «w-200». 
                </p>
                <p> 
                    Такой стиль позволяет минимизировать объем CSS-кода за счет повторного использования деклараций, а также сравнительно легко вводить изменения в модули, к примеру, при изменении технического задания.
                </p>
                <p> 
                    Однако у этого подхода есть существенные недостатки! Вот они:
                </p>
                <ul>
                    <li>наименования классов представляют собой описательные названия свойств, не описывая семантическую сущность элемента, что иногда может усложнить разработку;</li>
                    <li>настройки отображения элементов переносятся непосредственно в HTML (это не то, для чего были придуманы таблицы стилей, не так ли?).</li>
                </ul> 
                <p> 
                    В связи с этими недостатками, подход был встречен существенным объемом критики. Тем не менее, подход может оказаться эффективным для очень больших проектов - кажется, Yahoo! вполне довольны использованием ACSS (ссылка на интересную презентацию того же Тьерри Коблентца).
                    Кроме того, атомарный CSS используется в различных фреймворках для задания корректирующих стилей элементов и в некоторых слоях других методологий. 
                </p>
                <figure class="image">
                    <img src="../images/atomiccss.png" width="500" height="200" alt="">
                    <figcaption><i>Рисунок 5 - <b>Atomic CSS</b></i></figcaption>
                </figure>
            </article>
            <section>
                <h2 id="part5"><span class="subtitle">MCSS</span></h2>
            </section>
            <article contenteditable>
                <p> 

                    MCSS - многослойный CSS (Multilayer CSS). Этот стиль написания кода, зародившийся в компании «Одноклассники», предлагает разделить стили на несколько частей, называемых слоями.

                </p>
                <ul>
                    <li>Нулевой слой или фундамент - здесь содержится код, отвечающий за сброс стилей браузера (reset.css/normalize.css);</li>
                    <li>Базовый слой - включает в себя стили многократно используемых на сайте элементов: кнопок, полей ввода для текста, подсказок и т.п.;</li>
                    <li>Проектный слой - включает в себя отдельные модули, а также т.н. «контекст» - модификации элементов в зависимости от браузера клиента, устройства, на котором просматривается сайт/приложение, роли пользователя и т.п.;</li>
                    <li>Косметический слой - в этом разделе находится код, написанный в стиле OOCSS, осуществляющий мелкие изменения в внешнем виде элементов. Здесь рекомендуется оставлять только стили, влияющие на внешний вид и не способные поломать верстку сайта - цвета, некоторые некритичные отступы.</li>
                </ul> 
                <p> 

                    Очень важна иерархия взаимодействия слоев:

                </p>
                <ul>
                    <li>Слой фундамента задает нейтральные стили и не влияет на другие слои.</li>
                    <li>Элементы базового слоя могут влиять только на классы своего же слоя. Пример: иконки на сайте могут иметь размеры 25x25, но иконки в кнопках - 16x16.</li>
                    <li>Элементы проектного слоя могут влиять на базовый и проектный слой. Примеры: иконки в форме логина имеют особый размер 20x20; модуль «Покупка» может включать в себя форму логина, стили которой несколько модифицированы.</li>
                    <li>Косметический слой оформлен в виде описательных OOCSS-классов («атомарные» классы) и не влияет на другой CSS-код, избирательно применяясь в разметке.</li>
                </ul>
                <figure class="image">
                    <img src="../images/mcss.png" width="500" height="200" alt="">
                    <figcaption><i>Рисунок 6 - <b>MCSS</b></i></figcaption>
                </figure>
            </article>
            <section>
                <h2 id="part6"><span class="subtitle">AMCSS</span></h2>
            </section>
            <article contenteditable>
                <p> 
                    Название подхода означает «Модули атрибутов для CSS» (Attribute Modules for CSS). Это достаточно необычный подход, упоминания которого, тем не менее, все чаще встречаются в блогах гуру разработки.
                </p>
                <p> 
                    Если обобщить, этот способ является несколько более человеко-читаемым представлением БЭМ-структуры. Давайте рассмотрим пример:
                </p>
                <pre>
                    &lt;div class="button button--large button--blue"&gt;нопка&lt;/div&gt;
                </pre>
                <p> 
                    Такая цепочка классов не очень приятна для глаз, поэтому давайте сгруппируем эти значения по атрибутам.
                </p>
                <p> 
                    Вот что получится:
                </p>
                <pre>
                    &lt;div button="large blue"&gt;Кнопка&lt;/div&gt;
                </pre>
                <p> 
                    Во избежание коллизий имен неплохо бы добавить атрибутам неймспейсы, не так ли? Тогда код нашей кнопки примет следующий вид:
                </p>
                <pre>
                    &lt;div am-button="large blue"&gt;Кнопка&lt;/div&gt;
                </pre>
                <p> 
                    Если вы используете валидатор для проверки кода на корректность, не забывайте также добавить приставку «data-» перед названием атрибута.
                </p>
                <p> 
                    Для записи CSS-кода используется малоизвестный селектор «~=» (IE7+), который работает как атрибут класса: выбирает элементы, значения атрибутов которых содержат указанные слова, разделенные пробелами. Так, селектор вида a[class~=«link»][class~=«button»] аналогичен селектору a.class.button (даже по специфичности, так как специфичности селекторов по классу и по атрибуту равны друг другу!).
                </p>
                <p> 
                    Соответственно, CSS-код
                </p>
                <pre>
                    .button {...}
                    .button--large {...}
                    .button--blue{...}
                </pre>
                <p> 
                    Преобразуется в
                </p>
                <pre>
                    [am-button] {...}
                    [am-button~="large"] {...}
                    [am-button~="blue"] {...}
                </pre>
                <p>
                    Ну как? Если вы считаете такой код слишком оригинальным, для вас существует менее радикальная форма использования AMCSS:
                </p>
                <pre>
                &lt;div am-button am-button-large am-button-blue&gt;&lt;/div&gt;
                </pre>
                <figure class="image">
                    <img src="../images/amcss.png" width="500" height="200" alt="">
                    <figcaption><i>Рисунок 7 - <b>AMCSS</b></i></figcaption>
                </figure>
            </article>
            <section>
                <h2 id="part7"><span class="subtitle">FUN</span></h2>
            </section>
            <article contenteditable>
                <p>
                    FUN означает «плоская иерархия селекторов, служебные стили, компоненты с неймспейсами» (Flat hierarchy of selectors, Utility styles, Name-spaced components). Ну или веселье =)
                </p>
                <p>
                    За каждой буквой названия стоит определенный принцип:
                </p>
                <ul>
                    <li>F, плоская иерархия селекторов: в стилях рекомендуется использовать классы для выбора элементов, не вкладывать селекторы (избегать каскада без необходимости), а также не использовать id (если вы читали раздел БЭМ, вспомните про котят);</li>
                    <li>U, служебные классы: поощряется создание служебных атомарных стилей для решения типовых задач верстки, например, w100 для «width: 100%» или fr для «float: right»;</li>
                    <li>N, компоненты с неймспейсами: Бен рекомендует добавлять неймспейсы для задания стилей элементов конкретных модулей; такой подход позволит избежать совпадений в названиях классов.</li>
                </ul>
                <p> 
                    Некоторые разработчики отмечают, что код, написанный с использованием этих принципов достаточно удобно писать и поддерживать; в некотором роде автор взял лучшее от БЭМ и SMACSS и изложил эти техники в простой и лаконичной форме.
                </p>
                <p>
                    Такой подход накладывает достаточно мало требований по структуре кода и проекта, он лишь устанавливает предпочтительную форму записи селекторов и способ их использования в разметке. Но в небольших проектах этих правил может быть вполне достаточно для создания качественного кода.
                </p>
                <figure class="image">
                    <img src="../images/fun.png" width="500" height="200" alt="">
                    <figcaption><i>Рисунок 8 - <b>FUN</b></i></figcaption>
                </figure>
            </article>
            <aside>
                <br><br><br><div><a href="../content.html" class="button-small">Перейти к содержанию</a></div>
            </aside>
        </div>
        <footer>
            <p>Нижний Новгород, 2017</p>
        </footer>
    </body>
</html>